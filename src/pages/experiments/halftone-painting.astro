---
import { ClientRouter } from "astro:transitions";
import "../../styles/global.css";
import Experimental from "../../icons/Experimental.astro";

const { url } = Astro;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1"
    />
    <meta
      name="theme-color"
      content="#fdf6e3"
    />
    <meta
      name="color-scheme"
      content="light dark"
    />
    <meta
      http-equiv="X-UA-Compatible"
      content="ie=edge"
    />
    <link
      rel="canonical"
      href={url}
    />
    <meta
      property="og:url"
      content={url}
    />
    <meta
      property="og:locale"
      content="en_US"
    />
    <meta
      property="og:site_name"
      content="Carter McBride"
    />
    <link
      rel="icon"
      href="/favicon.svg"
      type="image/svg+xml"
    />
    <link
      rel="alternate"
      type="application/rss+xml"
      href={new URL("/blog/feed.xml", Astro.site)}
    />
    <link
      rel="manifest"
      href="/manifest.webmanifest"
    />
    <link
      rel="sitemap"
      href="/sitemap-index.xml"
    />
    <ClientRouter />

    <slot name="head" />

    <title>Halftone Painting | carter.works</title>

    <meta
      property="og:title"
      content="Halftone Painting"
    />
    <meta
      property="og:type"
      content="website"
    />

    <script type="module">
      const resolveCssColor = (colorString) => {
        const el = document.createElement("span");
        el.style.color = colorString;
        document.head.appendChild(el);
        const resolved = getComputedStyle(el).color;
        el.remove();
        return resolved;
      };
      const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
      const eased = (t) => 1 - Math.pow(1 - clamp(t, 0, 1), 3);
      const keyFromIJ = (i, j) => `${i},${j}`;
      const parseKey = (k) => k.split(",").map((v) => parseInt(v, 10));

      const withDPR = (canvas, widthCSS, heightCSS) => {
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        canvas.width = Math.round(widthCSS * dpr);
        canvas.height = Math.round(heightCSS * dpr);
        canvas.style.width = `${widthCSS}px`;
        canvas.style.height = `${heightCSS}px`;
        const ctx = canvas.getContext("2d", { alpha: false });
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        return { ctx, dpr };
      };

      class GridStore {
        #map = new Map();

        get(i, j) {
          return this.#map.get(keyFromIJ(i, j)) ?? 0;
        }
        set(i, j, value) {
          const k = keyFromIJ(i, j);
          if (value === 0 || value === null) this.#map.delete(k);
          else this.#map.set(k, value);
        }
        toggleFullHalf(i, j) {
          const cur = this.get(i, j);
          const next = cur === 1 ? 0.5 : 1;
          this.set(i, j, next);
          return next;
        }
        addFull(i, j) {
          this.set(i, j, 1);
          return 1;
        }
        remove(i, j) {
          this.set(i, j, 0);
        }
        clear() {
          this.#map.clear();
        }
        entries() {
          return this.#map.entries();
        }
        toJSON() {
          return JSON.stringify([...this.#map.entries()]);
        }
        static fromJSON(json) {
          const s = new GridStore();
          try {
            const arr = JSON.parse(json);
            arr.forEach(([k, v]) => s.#map.set(k, v));
          } catch {}
          return s;
        }
      }

      class HalftoneRenderer {
        #ghostCache = null;
        #raf = null;

        constructor(canvas, store, opts = {}) {
          this.canvas = canvas;
          this.store = store;

          this.cell = opts.cell ?? 14;
          this.dotRadius = opts.dotRadius ?? 2.8;
          this.ghostRadius = opts.ghostRadius ?? 0.9;

          this.hover = null;
          this.showGhost = false;

          this.#resize();

          this.colors = {
            bg: resolveCssColor("var(--color-blackish)"),
            full: resolveCssColor("var(--color-sepia)"),
            half: resolveCssColor(
              "color-mix(in oklch, var(--color-sepia) 35%, transparent)",
            ),
            ghost: resolveCssColor(
              "color-mix(in oklch, var(--color-sepia) 25%, transparent)",
            ),
            hover: resolveCssColor(
              "color-mix(in oklch, var(--color-sepia) 40%, transparent)",
            ),
          };

          window.addEventListener("resize", () => {
            this.#resize();
            this.requestDraw();
          });

          this.dirty = true;
          this.animations = [];
          this.tick = this.tick.bind(this);
        }

        #resize() {
          const { innerWidth: w, innerHeight: h } = window;
          const { ctx } = withDPR(this.canvas, w, h);
          this.ctx = ctx;
          this.cols = Math.ceil(w / this.cell);
          this.rows = Math.ceil(h / this.cell);
          this.#ghostCache = null;
        }

        setCellSize(n) {
          this.cell = n;
          this.dotRadius = Math.max(1.8, n * 0.22);
          this.ghostRadius = Math.max(0.6, n * 0.07);
          this.#resize();
          this.requestDraw();
        }

        setHover(i, j, x, y) {
          this.hover = { i, j, x, y };
          this.showGhost = true;
          this.requestDraw();
        }

        clearHover() {
          this.hover = null;
          this.showGhost = false;
          this.requestDraw();
        }

        ping(x, y) {
          this.animations.push({
            type: "pulse",
            x,
            y,
            t0: performance.now(),
            dur: 360,
          });
          this.requestDraw();
        }

        requestDraw() {
          this.dirty = true;
          if (!this.#raf) this.#raf = requestAnimationFrame(this.tick);
        }

        tick() {
          this.#raf = null;
          if (this.dirty || this.animations.length) {
            this.draw();
          }
          if (this.animations.length) {
            this.#raf = requestAnimationFrame(this.tick);
          }
        }

        draw() {
          const ctx = this.ctx;
          const w = this.canvas.clientWidth;
          const h = this.canvas.clientHeight;

          ctx.save();
          ctx.fillStyle = this.colors.bg;
          ctx.fillRect(0, 0, w, h);

          if (this.showGhost) {
            this.#drawGhostGrid();
          }

          this.#drawDots();

          if (this.hover) {
            const { x, y } = this.hover;
            ctx.fillStyle = this.colors.hover;
            ctx.beginPath();
            ctx.arc(x, y, this.dotRadius * 0.95, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = this.colors.hover;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(x, y, this.dotRadius * 1.7, 0, Math.PI * 2);
            ctx.stroke();
          }

          this.#drawAnimations();

          ctx.restore();
          this.dirty = false;
        }

        #drawGhostGrid() {
          const ctx = this.ctx;
          const key = `${this.cols}x${this.rows}-${this.cell}-${this.ghostRadius}`;
          if (!this.#ghostCache || this.#ghostCache.key !== key) {
            const path = new Path2D();
            for (let j = 0; j < this.rows; j++) {
              const y = j * this.cell + this.cell / 2;
              for (let i = 0; i < this.cols; i++) {
                const x = i * this.cell + this.cell / 2;
                path.moveTo(x + this.ghostRadius, y);
                path.arc(x, y, this.ghostRadius, 0, Math.PI * 2);
              }
            }
            this.#ghostCache = { key, path };
          }
          ctx.globalAlpha = 1;
          ctx.fillStyle = this.colors.ghost;
          ctx.fill(this.#ghostCache.path);
        }

        #drawDots() {
          const ctx = this.ctx;
          const pathFull = new Path2D();
          const pathHalf = new Path2D();
          const R = this.dotRadius;

          for (const [k, v] of this.store.entries()) {
            const [i, j] = parseKey(k);
            const x = i * this.cell + this.cell / 2;
            const y = j * this.cell + this.cell / 2;
            const path = v === 1 ? pathFull : pathHalf;
            path.moveTo(x + R, y);
            path.arc(x, y, R, 0, Math.PI * 2);
          }

          ctx.globalAlpha = 1;
          ctx.fillStyle = this.colors.full;
          ctx.fill(pathFull);

          ctx.fillStyle = this.colors.half;
          ctx.fill(pathHalf);
        }

        #drawAnimations() {
          if (!this.animations.length) return;
          const now = performance.now();
          const ctx = this.ctx;
          const R = this.dotRadius * 1.2;

          this.animations = this.animations.filter((a) => {
            const t = (now - a.t0) / a.dur;
            if (t >= 1) return false;
            const e = eased(t);
            ctx.save();
            ctx.globalAlpha = (1 - e) * 0.45;
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(a.x, a.y, R + e * this.cell * 0.9, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
            return true;
          });
        }

        exportPNG() {
          const w = this.canvas.clientWidth;
          const h = this.canvas.clientHeight;
          const off = document.createElement("canvas");
          const { ctx } = withDPR(off, w, h);

          ctx.fillStyle = this.colors.bg;
          ctx.fillRect(0, 0, w, h);

          const R = this.dotRadius;
          for (const [k, v] of this.store.entries()) {
            const [i, j] = parseKey(k);
            const x = i * this.cell + this.cell / 2;
            const y = j * this.cell + this.cell / 2;
            ctx.beginPath();
            ctx.arc(x, y, R, 0, Math.PI * 2);
            ctx.fillStyle = v === 1 ? this.colors.full : this.colors.half;
            ctx.fill();
          }

          return off.toDataURL("image/png");
        }
      }

      class EditorController {
        constructor(canvas) {
          this.store = new GridStore();
          this.renderer = new HalftoneRenderer(canvas, this.store);

          this.cell = this.renderer.cell;

          this.pointerDown = false;
          this.paintMode = null;
          this.lastPaintedKey = null;

          canvas.addEventListener("pointermove", (e) => this.onMove(e));
          canvas.addEventListener("pointerleave", () => this.onLeave());
          canvas.addEventListener("pointerdown", (e) => this.onDown(e));
          window.addEventListener("pointerup", (e) => this.onUp(e));
          canvas.addEventListener("contextmenu", (e) => e.preventDefault());

          window.addEventListener("keydown", (e) => this.onKey(e));

          const cellSlider = document.getElementById("cellSize");
          cellSlider.value = String(this.cell);
          cellSlider.addEventListener("input", (e) => {
            const n = parseInt(e.target.value, 10);
            this.renderer.setCellSize(n);
            this.cell = n;
          });

          document
            .getElementById("clearBtn")
            .addEventListener("click", () => this.clear());
          document
            .getElementById("saveBtn")
            .addEventListener("click", () => this.save());
        }

        xyFromEvent(e) {
          const rect = this.renderer.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          return { x, y };
        }

        ijFromXY(x, y) {
          const i = Math.floor(x / this.cell);
          const j = Math.floor(y / this.cell);
          return { i, j };
        }

        centerOf(i, j) {
          const x = i * this.cell + this.cell / 2;
          const y = j * this.cell + this.cell / 2;
          return { x, y };
        }

        onMove(e) {
          const { x, y } = this.xyFromEvent(e);
          const { i, j } = this.ijFromXY(x, y);
          const c = this.centerOf(i, j);
          this.renderer.setHover(i, j, c.x, c.y);

          if (this.pointerDown) {
            this.paintAt(i, j, c.x, c.y, true);
          }
        }

        onLeave() {
          this.renderer.clearHover();
          this.pointerDown = false;
          this.paintMode = null;
          this.lastPaintedKey = null;
        }

        onDown(e) {
          e.preventDefault();
          const { x, y } = this.xyFromEvent(e);
          const { i, j } = this.ijFromXY(x, y);
          const c = this.centerOf(i, j);

          this.pointerDown = true;
          this.lastPaintedKey = null;

          if (e.button === 0) {
            const has = this.store.get(i, j);
            if (has === 0) {
              this.paintMode = "addFull";
              this.store.addFull(i, j);
            } else {
              this.paintMode = "toggle";
              this.store.toggleFullHalf(i, j);
            }
            this.renderer.ping(c.x, c.y);
            this.renderer.requestDraw();
            this.lastPaintedKey = keyFromIJ(i, j);
          }

          if (e.button === 2) {
            this.store.remove(i, j);
            this.renderer.ping(c.x, c.y);
            this.renderer.requestDraw();
            this.paintMode = "erase";
            this.lastPaintedKey = keyFromIJ(i, j);
          }
        }

        onUp() {
          this.pointerDown = false;
          this.paintMode = null;
          this.lastPaintedKey = null;
        }

        paintAt(i, j, x, y, dragging = false) {
          const k = keyFromIJ(i, j);
          if (dragging && k === this.lastPaintedKey) return;

          if (this.paintMode === "addFull") {
            if (this.store.get(i, j) === 0) {
              this.store.addFull(i, j);
              this.renderer.ping(x, y);
            }
          } else if (this.paintMode === "toggle") {
            if (this.store.get(i, j) !== 0) {
              this.store.toggleFullHalf(i, j);
              this.renderer.ping(x, y);
            } else {
              this.store.addFull(i, j);
              this.renderer.ping(x, y);
            }
          } else if (this.paintMode === "erase") {
            if (this.store.get(i, j) !== 0) {
              this.store.remove(i, j);
              this.renderer.ping(x, y);
            }
          }

          this.lastPaintedKey = k;
          this.renderer.requestDraw();
        }

        onKey(e) {
          if (e.key.toLowerCase() === "c") {
            this.clear();
          } else if (e.key.toLowerCase() === "s") {
            this.save();
          }
        }

        clear() {
          this.store.clear();
          this.renderer.requestDraw();
        }

        save() {
          const url = this.renderer.exportPNG();
          const a = document.createElement("a");
          a.href = url;
          const ts = new Date()
            .toISOString()
            .replace(/[:.]/g, "-")
            .slice(0, 19);
          a.download = `halftone-${ts}.png`;
          document.body.appendChild(a);
          a.click();
          a.remove();
        }
      }

      const canvas = document.getElementById("stage");
      const editor = new EditorController(canvas);
      editor.renderer.requestDraw();
    </script>
  </head>
  <body
    class="m-0 bg-blackish text-sepia overflow-hidden select-none font-sans"
  >
    <header class="prose mx-auto p-4">
      <h1>Halftone Painting</h1>
      <p>
        <blockquote>
          Halftone is the reprographic technique that simulates continuous-tone
          imagery through the use of dots, varying either in size or in spacing,
          thus generating a gradient-like effect.
        </blockquote>
        —<a href="https://en.wikipedia.org/wiki/Halftone"
          ><cite>Wikipedia</cite></a
        >
      </p>
      <p>
        <em>Not mobile friendly.</em>
      </p>
      <p>
        <a
          href="/experiments"
          class="inline-flex items-center gap-1"
          ><Experimental /> Go back to experiments</a
        >
      </p>
    </header>
    <main>
      <div
        id="corner"
        class="flex justify-center gap-2 opacity-[0.85] transition-opacity duration-150 hover:opacity-100"
      >
        <button
          id="clearBtn"
          title="Clear (C)"
          class="bg-white/10 text-white border border-white/10 px-2.5 py-1.5 rounded-md text-xs hover:bg-white/15"
          >Clear</button
        >
        <button
          id="saveBtn"
          title="Save PNG (S)"
          class="bg-white/10 text-white border border-white/10 px-2.5 py-1.5 rounded-md text-xs hover:bg-white/15"
          >Save PNG</button
        >
      </div>

      <canvas
        id="stage"
        aria-label="Halftone editor"
        class="block w-screen h-[100dvh] outline-none cursor-crosshair"
      ></canvas>

      <div
        id="hud"
        class="fixed left-1/2 bottom-4 -translate-x-1/2 bg-white/10 backdrop-blur-sm text-white px-3 py-2 text-xs tracking-[0.02em] rounded-full border border-white/10 inline-flex items-center gap-3 opacity-[0.85] transition-all"
      >
        <span>Click: full • Click again: half • Right click: clear circle</span>
        <div class="w-px h-[14px] bg-white/15"></div>
        <label class="inline-flex items-center gap-2">
          <span>Grid</span>
          <input
            id="cellSize"
            type="range"
            min="8"
            max="28"
            step="1"
            value="14"
            aria-label="Grid size"
            class="w-32 h-5"
          />
        </label>
      </div>
    </main>
  </body>
</html>
